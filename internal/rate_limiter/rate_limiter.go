package rate_limiter

import (
	"context" // *** ДОБАВЛЕНО ***
	"log"
	"sync"
	"time"
	// Для использования math.Min и других математических функций
)

// Request представляет один запрос к Rate Limiter'у.
// Каждый запрос имеет определенный "вес".
type Request struct {
	Weight int           // Вес запроса (например, 1 для простого запроса, 200 для snapshot Binance depth=1000)
	Grant  chan struct{} // Канал, через который Rate Limiter сигнализирует, что запрос разрешен.
	// Когда запрос разрешен, в этот канал отправляется пустое значение {}.
	// Этот канал будет закрыт при остановке лимитера.
}

// Limiter управляет ограничением скорости запросов на основе их "веса".
// Он позволяет пропускать определенный общий вес запросов в заданный интервал времени.
type Limiter struct {
	mu sync.Mutex // Мьютекс для защиты доступа к полям лимитера из разных горутин

	limit    int           // Общий максимальный вес, разрешенный за один интервал времени (например, 1200 для Binance в минуту)
	interval time.Duration // Интервал времени, за который действует лимит (например, 1 минута)

	currentWeight int // Текущий накопленный вес запросов в текущем интервале.
	// Этот вес сбрасывается в 0 в начале каждого нового интервала.

	requests []Request // Очередь ожидающих запросов.
	// Если запрос не может быть разрешен немедленно (превышен текущий лимит), он ставится в эту очередь.

	cleanerChan chan struct{} // используется для сигнализации фоновой горутине runCleaner

	// *** ДОБАВЛЕНО *** Контекст и функция отмены для graceful shutdown
	ctx    context.Context
	cancel context.CancelFunc // Функция для отмены контекста лимитера

	wg sync.WaitGroup // WaitGroup для ожидания завершения фоновых горутин лимитера (например, runCleaner)
}

// NewLimiter создает и инициализирует новый Rate Limiter.
// ctx: Контекст приложения, который будет использоваться для остановки лимитера.
// limit: общий вес, разрешенный за interval.
// interval: интервал времени (например, 1 минута).
// *** ИЗМЕНЕНА СИГНАТУРА ***
func NewLimiter(ctx context.Context, limit int, interval time.Duration) *Limiter {
	// Создаем контекст для лимитера, производный от переданного контекста.
	// Это позволяет остановить лимитер либо отменой внешнего ctx, либо вызовом l.Stop().
	limiterCtx, limiterCancel := context.WithCancel(ctx) // *** ИСПОЛЬЗУЕМ ПЕРЕДАННЫЙ ctx ***

	// Создаем экземпляр Limiter.
	l := &Limiter{
		limit:         limit,
		interval:      interval,
		currentWeight: 0,
		requests:      make([]Request, 0), // Инициализируем слайс для очереди
		cleanerChan:   make(chan struct{}, 1),
		// *** ДОБАВЛЕНО/ИЗМЕНЕНО *** Сохраняем контекст и функцию отмены
		ctx:    limiterCtx,
		cancel: limiterCancel,
		// stopChan удален
	}

	// Добавляем 1 в WaitGroup, потому что запускаем одну фоновую горутину (runCleaner).
	l.wg.Add(1)
	// Запускаем фоновую горутину, которая будет управлять сбросом веса и обработкой очереди.
	// *** ПЕРЕДАЕМ КОНТЕКСТ ЛИМИТЕРА ***
	go l.runCleaner(l.ctx)

	log.Printf("Rate Limiter: Запущен с лимитом %d веса за %s", limit, interval)

	return l // Возвращаем указатель на созданный лимитер
}

// Wait блокирует вызывающую горутину до тех пор, пока запрос с заданным весом weight не будет разрешен
// или пока переданный контекст не будет отменен, или пока лимитер не будет остановлен.
// ctx: Контекст, который может прервать ожидание.
// Возвращает true, если запрос разрешен.
// Возвращает false, если ожидание было прервано отменой ctx или остановкой лимитера.
// *** ИЗМЕНЕНА СИГНАТУРА ***
func (l *Limiter) Wait(ctx context.Context, weight int) bool { // *** ПРИНИМАЕМ context ***
	// Проверяем, чтобы вес не был отрицательным.
	if weight < 0 {
		weight = 0
	}

	// Проверяем контекст ДО захвата мьютекса. Если контекст уже отменен, выходим немедленно.
	select {
	case <-ctx.Done():
		log.Printf("Rate Limiter: Ожидание прервано отменой переданного контекста перед обработкой.")
		return false // Возвращаем false, т.к. ожидание прервано.
	default:
		// Контекст активен, продолжаем.
	}

	// Создаем структуру Request для нашего запроса.
	req := Request{
		Weight: weight,
		Grant:  make(chan struct{}, 1),
	}

	l.mu.Lock() // Захватываем мьютекс для работы с общими полями (currentWeight, requests)

	// Попытка разрешить запрос немедленно.
	if l.currentWeight+weight <= l.limit {
		l.currentWeight += weight // ...увеличиваем текущий вес...
		l.mu.Unlock()             // ...и сразу освобождаем мьютекс. Запрос разрешен.

		// log.Printf("Rate Limiter: Granted %d weight immediately. Current: %d/%d", weight, l.currentWeight, l.limit)

		// Сигнализируем cleaner'у, что, возможно, появились новые возможности разрешить запросы из очереди
		select {
		case l.cleanerChan <- struct{}{}:
			// Сигнал отправлен успешно
		default:
			// Канал cleanerChan полон, сигнал проигнорирован. Это нормально.
		}

		return true // Возвращаем true, т.к. запрос разрешен немедленно.
	}

	// Если не удалось разрешить запрос немедленно, ставим его в очередь.
	l.requests = append(l.requests, req) // Добавляем запрос в конец слайса-очереди.
	log.Printf("Rate Limiter: Queued request with %d weight. Queue size: %d", weight, len(l.requests))
	l.mu.Unlock() // Освобождаем мьютекс после модификации очереди.

	// Сигнализируем cleaner'у, что в очереди появились новые запросы.
	select {
	case l.cleanerChan <- struct{}{}:
		// Сигнал отправлен успешно
	default:
		// Канал cleanerChan полон.
	}

	// Теперь ждем. Горутина блокируется здесь до тех пор, пока:
	// 1. В канал req.Grant не будет отправлено значение (сигнал от cleaner'а о разрешении).
	// 2. Канал req.Grant не будет закрыт (сигнал от grantAll при остановке лимитера).
	// 3. Переданный контекст ctx не будет отменен.
	select {
	case <-req.Grant: // Ждем разрешения от cleaner'а или закрытия канала Grant
		// Получили сигнал о разрешении от cleaner'а ИЛИ канал закрылся.
		// Если канал закрылся, это означает, что лимитер останавливается (см. grantAll).
		// Но в этом случае l.ctx.Done() тоже будет срабатывать, так что этот кейс
		// в теории срабатывает только при успешном получении Grant.
		// log.Printf("Rate Limiter: Granted %d weight from queue.", weight)
		return true // Возвращаем true, запрос разрешен из очереди.
	case <-ctx.Done(): // *** ДОБАВЛЕНО *** Слушаем переданный контекст
		log.Printf("Rate Limiter: Ожидание прервано отменой переданного контекста: %v", ctx.Err())
		// Нам нужно удалить этот запрос из очереди, т.к. мы больше его не ждем.
		// Это требует повторного захвата мьютекса. Это редкий случай, поэтому допустимо.
		l.mu.Lock()
		// Ищем запрос в очереди. Это может быть неэффективно для очень длинных очередей.
		// Для оптимизации можно использовать map или более сложную структуру очереди.
		foundIndex := -1
		for i := range l.requests { // Итерируемся по индексу
			// Сравниваем каналы Grant, т.к. это уникальный идентификатор запроса.
			if l.requests[i].Grant == req.Grant { // Используем l.requests[i]
				foundIndex = i
				break
			}
		}
		if foundIndex != -1 {
			// Удаляем запрос из очереди.
			l.requests = append(l.requests[:foundIndex], l.requests[foundIndex+1:]...)
			log.Printf("Rate Limiter: Удален отмененный запрос из очереди. Очередь: %d", len(l.requests))
		}
		l.mu.Unlock()
		// Не закрываем req.Grant здесь, т.к. он мог быть уже закрыт grantAll,
		// если l.ctx.Done() сработал почти одновременно с закрытием l.stopChan.
		// grantAll позаботится о закрытии всех ожидающих каналов.
		return false // Возвращаем false, сигнализируя, что ожидание было прервано.
		// Удален кейс <-l.stopChan, т.к. он теперь покрывается <-l.ctx.Done() через контекст лимитера
	}
}

// runCleaner - фоновая горутина, которая периодически выполняется.
// ctx: Контекст лимитера для получения сигнала остановки.
// *** ИЗМЕНЕНА СИГНАТУРА ***
func (l *Limiter) runCleaner(ctx context.Context) { // *** ПРИНИМАЕМ context ***
	defer l.wg.Done() // Декрементируем WaitGroup при выходе из горутины.
	log.Println("Rate Limiter: Cleaner горутина запущена")

	ticker := time.NewTicker(l.interval)
	defer ticker.Stop() // Останавливаем тикер при выходе из горутины.

	// Основной цикл работы cleaner'а.
	for {
		select {
		case <-ticker.C: // Срабатывает каждый раз по истечении l.interval
			// *** ДОБАВЛЕН ПРИЕМНИК ***
			l.resetAndGrant() // Сброс веса и попытка разрешить ожидающие запросы.
		case <-l.cleanerChan: // Получили сигнал извне (например, из Wait), что нужно проверить очередь
			// *** ДОБАВЛЕН ПРИЕМНИК ***
			l.tryGrantPending() // Попытка разрешить ожидающие запросы.
		case <-ctx.Done(): // *** ИЗМЕНЕНО *** Слушаем контекст лимитера
			log.Printf("Rate Limiter: Cleaner горутина завершается по сигналу контекста: %v", ctx.Err())
			// При остановке нужно разблокировать все ожидающие запросы в очереди.
			// *** ДОБАВЛЕН ПРИЕМНИК ***
			l.grantAll() // Разблокируем все запросы (они получат false из Wait() благодаря закрытию канала Grant)
			return       // Выходим из горутины cleaner'а.
		}
	}
}

// resetAndGrant сбрасывает накопленный вес и пытается разрешить ожидающие запросы.
// Должен вызываться при срабатывании интервала.
// *** ДОБАВЛЕН ПРИЕМНИК ***
func (l *Limiter) resetAndGrant() { // *** ДОБАВЛЕН RECEIVER ***
	l.mu.Lock()         // Захватываем мьютекс для работы с общими полями.
	defer l.mu.Unlock() // Гарантируем освобождение мьютекса.

	// Сбрасываем накопленный вес в начале нового интервала.
	l.currentWeight = 0
	log.Printf("Rate Limiter: Вес сброшен. Текущий вес: %d/%d", l.currentWeight, l.limit)

	// После сброса веса, пытаемся разрешить запросы из очереди requests.
	// *** ДОБАВЛЕН ПРИЕМНИК ***
	l.tryGrantPendingLocked()
}

// tryGrantPending пытается разрешить запросы из очереди requests.
// Вызывается после сброса веса или при получении сигнала cleanerChan.
// Эта версия захватывает и освобождает мьютекс.
// *** ДОБАВЛЕН ПРИЕМНИК ***
func (l *Limiter) tryGrantPending() { // *** ДОБАВЛЕН RECEIVER ***
	l.mu.Lock()         // Захватываем мьютекс.
	defer l.mu.Unlock() // Гарантируем освобождение мьютекса.
	// *** ДОБАВЛЕН ПРИЕМНИК ***
	l.tryGrantPendingLocked() // Вызываем внутреннюю версию, работающую под мьютексом.
}

// tryGrantPendingLocked - внутренняя версия tryGrantPending.
// Предполагает, что мьютекс l.mu уже захвачен вызывающей горутиной.
// Проходит по очереди запросов и разрешает те, которые вписываются в текущий оставшийся лимит.
// *** ДОБАВЛЕН ПРИЕМНИК ***
func (l *Limiter) tryGrantPendingLocked() { // *** ДОБАВЛЕН RECEIVER ***
	// Создаем временный слайс для запросов, которые останутся в очереди.
	newRequests := make([]Request, 0, len(l.requests))

	// Итерируемся по текущей очереди requests.
	for _, req := range l.requests {
		// Проверяем, можно ли разрешить этот запрос:
		// Если текущий вес плюс вес запроса не превышает общий лимит...
		if l.currentWeight+req.Weight <= l.limit {
			// ...то разрешаем запрос.
			l.currentWeight += req.Weight // Увеличиваем текущий вес.

			// Отправляем сигнал о разрешении в канал Grant запроса.
			select {
			case req.Grant <- struct{}{}:
				// Сигнал успешно отправлен. Горутина Wait() для этого запроса будет разблокирована.
				// log.Printf("Rate Limiter: Granted %d weight from queue.", req.Weight)
			default:
				// Этот случай маловероятен для буферизованного канала размером 1,
				// если только Wait() горутина не завершилась неожиданно, не забрав сигнал.
				log.Println("Rate Limiter: Warning: Failed to send grant signal to request channel.")
				// В данном случае, считаем, что запрос все равно разрешен.
			}
			// Продолжаем итерацию, чтобы проверить следующий запрос в исходной очереди.

		} else {
			// Если запрос не может быть разрешен (превышает лимит с текущим весом),
			// добавляем его во временный слайс newRequests.
			newRequests = append(newRequests, req)
			// Здесь мы не прерываем цикл, а проверяем все запросы в очереди за один проход.
			// Это проще, хотя для очень длинных очередей можно было бы оптимизировать,
			// т.к. запросы в конце списка, скорее всего, тоже не влезут.
		}
	}
	// После прохода по всем запросам, заменяем старую очередь на новую, содержащую только те, что остались ждать.
	l.requests = newRequests
	// log.Printf("Rate Limiter: Проверена очередь. Осталось в очереди: %d. Текущий вес: %d/%d", len(l.requests), l.currentWeight, l.limit)

}

// grantAll закрывает канал Grant для всех ожидающих запросов в очереди.
// Должен вызываться только один раз при остановке лимитера.
// Вызывается под мьютексом, но мьютекс будет разблокирован после итерации.
// *** ДОБАВЛЕН ПРИЕМНИК ***
func (l *Limiter) grantAll() { // *** ДОБАВЛЕН RECEIVER ***
	l.mu.Lock()         // Захватываем мьютекс, чтобы безопасно работать с l.requests
	defer l.mu.Unlock() // Гарантируем разблокировку

	log.Printf("Rate Limiter: Разблокирование %d ожидающих запросов при остановке...", len(l.requests))

	for _, req := range l.requests {
		// Проверяем, что канал еще не закрыт (хотя в теории не должен быть).
		select {
		case _, ok := <-req.Grant:
			if !ok {
				// Канал уже закрыт, пропускаем.
				continue
			}
		default:
			// Канал открыт или пуст, продолжаем.
		}
		close(req.Grant) // Закрываем канал Grant. Ожидающие Wait() горутины будут разблокированы.
	}
	// После разблокировки, очередь запросов больше не нужна.
	l.requests = nil
	log.Println("Rate Limiter: Все ожидающие запросы разблокированы.")
}

// Stop корректно останавливает Rate Limiter.
// Вызывает отмену контекста лимитера и ожидает завершения его фоновых горутин.
// *** ИЗМЕНЕНА ЛОГИКА ***
// *** ДОБАВЛЕН ПРИЕМНИК ***
func (l *Limiter) Stop() { // *** ДОБАВЛЕН RECEIVER ***
	log.Println("Rate Limiter: Получен внешний сигнал остановки (Stop()).")
	l.cancel() // Вызываем функцию отмены контекста лимитера.
	// Ожидаем завершения фоновой горутины (runCleaner).
	l.wg.Wait()
	log.Println("Rate Limiter: Остановлен.")
}

// GetBinanceDepthWeight вычисляет приблизительный вес запроса к REST API Binance /api/v3/depth
// в зависимости от запрошенного лимита глубины.
// Источник: https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md#limits
func GetBinanceDepthWeight(limit int) int {
	switch {
	case limit == 1:
		return 1
	case limit >= 5 && limit <= 100:
		return 20
	case limit == 500:
		return 100
	case limit == 1000:
		return 200
	case limit == 5000:
		return 1000 // Внимание: лимит 5000 может требовать отдельного одобрения от Binance.
	default:
		// Для других (нестандартных) лимитов используем вес, соответствующий 1000, или безопасное значение.
		// Это предположение, лучше использовать только стандартные лимиты из документации Binance.
		log.Printf("Rate Limiter: Warning: Неизвестный лимит Binance depth %d, использую вес 200 (как для 1000). Используйте стандартные лимиты (1, 5-100, 500, 1000).", limit)
		return 200
	}
}

// TODO: Добавить функцию GetBybitDepthWeight(limit int) int, если Bybit REST тоже используется для snapshot'ов
// (Для Bybit V5 orderbook.{depth} по WS обычно присылает snapshot при подписке, возможно, REST snapshot не нужен для ресинка)
